#pragma config(Sensor, S1,     ,               sensorI2CMindsensorsDist)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
This is utility program to use  with mindsensors.com DIST-NX sensor.
This program use the adress of 0x02 for the DIST-Nx
(c) mindsensors.com 2010, 2011
This program is free software. You can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 3 of the License.
Read the license at: http://www.gnu.org/licenses/gpl.txt
*/

#define          DistID                0x02
#define          DistCommandReg        0x41
#define          DistReadResult        0x42
#define          DistReadDistance      0x42
#define          DistReadVoltage       0x44

#define          DISTON                   0x45
#define          DISTOFF                  0x44


#define           DistPort                S1    // Connect sensor to this Port!!

//
// Counter to keep track of the number of times a button is pressed.
//
int nLeftButton  = 0;
int nRightButton = 0;
int nEnterButton = 0;
int nExitButton  = 0;


task ButtonTask()
{
	//
	// Set task to highest priority so that it will run to completion. This will minimze the small
	// chance of task execution beeing delayed until after button is released; if this happens, then
	// the keypress will be lost.
	//
	nSchedulePriority   = kHighPriority;

	//
	// Update count of times each button is pushed. If using this program as a template, replace these
	// statements with your own custom action.
	//
	switch (nNxtButtonPressed)
	{
	case kLeftButton:    ++nLeftButton;         break;
	case kRightButton:  ++nRightButton;        break;
	case kEnterButton:  ++nEnterButton;        break;
	case kExitButton:    ++nExitButton;        break;
	}
	return;
}


//////////////////////////////////////////////////////////////////////////////
//
//     Read the Distance  data from Dist sensor
//
//
/////////////////////////////////////////////////////////////////////////////

int  GetDistance()
{
	byte replyMsg[2];
	int Distance;
	byte  distMsg[5];
	const byte MsgSize = 0;
	const byte DistAddress = 1;
	const byte ReadAddress = 2;
	distMsg[MsgSize] = 2;
	distMsg[DistAddress] = DistID;
	distMsg[ReadAddress] = DistReadDistance;

	while (nI2CStatus[DistPort] == STAT_COMM_PENDING) // Wait for I2C bus to be ready
	{ // do nothing
	}

	if ( nI2CStatus[DistPort] != NO_ERR ) {        // probably sensor is missing.
		nxtDisplayTextLine(6, ">>00E: %d", nI2CStatus[DistPort]);
		return (-1);
	}

	sendI2CMsg(DistPort, &distMsg[0], 2);           // Send the message

	while (nI2CStatus[DistPort] == STAT_COMM_PENDING) // Wait for I2C bus to be ready
	{ // do nothing
	}

	if ( nI2CStatus[DistPort] != NO_ERR ) {            // probably sensor is missing.
		nxtDisplayTextLine(6, ">>00E: %d", nI2CStatus[DistPort]);
		return (-1);
	}

	readI2CReply(DistPort, &replyMsg[0], 2);
	if ( replyMsg[0] == -1 ) { // -1 is reserved to report errors, so
		Distance = 0; // change it to zero.
	}
	else{
		Distance = ( 0x00FF & replyMsg[0] );
		Distance += ( (0x00FF & replyMsg[1]) <<8 );
	}

	return(Distance);
}

//////////////////////////////////////////////////////////////////////////////
//
//      Read the Distance  data from Dist sensor
//
//
/////////////////////////////////////////////////////////////////////////////

int  GetVoltage()
{
	byte replyMsg[2];
	int Voltage;
	byte distMsg[5];
	const byte MsgSize      = 0;
	const byte DistAddress  = 1;
	const byte ReadAddress  = 2;

	distMsg[MsgSize] = 2;
	distMsg[DistAddress] = DistID ;
	distMsg[ReadAddress] = DistReadVoltage ;

	while (nI2CStatus[DistPort] == STAT_COMM_PENDING)   // Wait for I2C bus to be ready
	{ // do nothing
	}

	if ( nI2CStatus[DistPort] != NO_ERR ) {           // probably sensor is missing.
		return (-1);
	}

	sendI2CMsg(DistPort, &distMsg[0], 2);              // Send the message

	while (nI2CStatus[DistPort] == STAT_COMM_PENDING) // Wait for I2C bus to be ready
	{ // do nothing
	}

	if ( nI2CStatus[DistPort] != NO_ERR ) {           // probably sensor is missing.
		return (-1);
	}

	readI2CReply(DistPort, &replyMsg[0], 2);
	if ( replyMsg[0] == -1 ) { // -1 is reserved to report errors, so
		Voltage = 0; // change it to zero.
	}
	else{
		Voltage = ( 0x00FF & replyMsg[0] );
		Voltage += ( (0x00FF & replyMsg[1]) <<8 );
	}
	return(Voltage);
}


//////////////////////////////////////////////////////////////////////////////
//
//     send command to  Dist sensor
//
//
/////////////////////////////////////////////////////////////////////////////

char distCommand(byte distCommand)
{
	byte distMsg[5];
	const byte MsgSize            = 0;
	const byte DistAddress        = 1;
	//const byte ReadAddress        = 2;
	const byte CommandAddress     = 2;
	const byte Command = 3;

	// Build the I2C message
	distMsg[MsgSize] = 3;
	distMsg[DistAddress]  = DistID;
	distMsg[CommandAddress] = DistCommandReg ;
	distMsg[Command] = distCommand;

	while (nI2CStatus[DistPort] == STAT_COMM_PENDING)                // Wait for I2C bus to be ready
	{ // do nothing
	}

	if ( nI2CStatus[DistPort] != NO_ERR ) {                           // probably sensor is missing.
		return (-1);
	}
	sendI2CMsg(DistPort, &distMsg[0], 0);                              // Send the message
	return (1);
}

void i2c_flush(tSensors s)
{
	int n;
	byte dump[8];

	while (nI2CStatus[s] == STAT_COMM_PENDING)
	{ // do nothing
	}

	n = nI2CBytesReady[s];
	while (n > 0) {
		while (nI2CStatus[s] == STAT_COMM_PENDING)
		{ // do nothing
		}

		readI2CReply(s, &dump[0], n);
		while (nI2CStatus[s] == STAT_COMM_PENDING)
		{ // do nothing
		}

		n = nI2CBytesReady[s];
	}
}


//////////////////////////////////////////////////////////////////////////////
//
//      Display the reading on NXT screen
//
/////////////////////////////////////////////////////////////////////////////

task main()
{
	nNxtButtonTask    = ButtonTask;
	nNxtExitClicks  = 3; // Triple clicking EXIT button will terminate program
	int Distance,Voltage;
	SensorType[DistPort] = sensorI2CCustom9V;
	nI2CBytesReady[DistPort] = 0;

	i2c_flush ( DistPort );

	// power the sensor ON.
	distCommand(DISTON);
	nxtDisplayTextLine(0, "mindsensors.com");
	nxtDisplayTextLine(1, "Dist sensor Demo");
	nxtDisplayTextLine(2, "use Port: 1");

	while(!nExitButton)
	{
		Distance = 0;
		Distance = GetDistance();     //read the distance in mm
		nxtDisplayTextLine(4,"Distance= %d mm", Distance); // display the distance
		Voltage = 0;
		Voltage = GetVoltage();      //read the voltage in mV
		nxtDisplayTextLine(5,"Voltage= %d mV", Voltage);  //display the voltage
	}

	// power of the sensor.
	distCommand(DISTOFF);
	StopAllTasks();
}
